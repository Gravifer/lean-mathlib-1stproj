namespace tpil
section cpt7 -- # Inductive types
set_option autoImplicit true
set_option relaxedAutoImplicit true
set_option guard_msgs.diff true

-- ## §7.1 Enumerated types
inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday
#check Weekday.sunday
#check Weekday.monday
open Weekday
#check sunday
#check monday

inductive Weekday' where -- can omit type name when declaring each constructor
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday

/- The elimination principle, `Weekday.rec`,
    is defined along with the type `Weekday` and its constructors.
  It is also known as a recursor, and it is what makes the type "inductive":
    it allows us to define a function on `Weekday`
      by assigning values corresponding to each constructor.
  The intuition is that an inductive type is exhaustively generated by the constructors,
    and has no elements beyond those they construct. -/
#check Weekday.rec
#print Weekday.rec

open Weekday
def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    => 1
  | monday    => 2
  | tuesday   => 3
  | wednesday => 4
  | thursday  => 5
  | friday    => 6
  | saturday  => 7

/- When using Lean's logic, the `match` expression is compiled
    using the recursor `Weekday.rec` generated when you declare the inductive.
  This ensures that the resulting term is well-defined in the type theory. -/

set_option pp.all true
#print numberOfDay
#print numberOfDay.match_1
#print Weekday.casesOn

/- When declaring an inductive datatype, you can use deriving `Repr`
    to instruct Lean to generate a function that converts objects into text.
  This function is used by the `#eval` command. If no `Repr` exists,
  `#eval` attempts to derive one on the spot. -/
#eval Weekday.sunday
deriving instance Repr for Weekday

namespace Weekday
  def next (d : Weekday) : Weekday :=
    match d with
    | sunday    => monday
    | monday    => tuesday
    | tuesday   => wednesday
    | wednesday => thursday
    | thursday  => friday
    | friday    => saturday
    | saturday  => sunday

  def previous (d : Weekday) : Weekday :=
    match d with
    | sunday    => saturday
    | monday    => sunday
    | tuesday   => monday
    | wednesday => tuesday
    | thursday  => wednesday
    | friday    => thursday
    | saturday  => friday

  #eval next (next tuesday)
  #eval next (previous tuesday)
  example : next (previous tuesday) = tuesday :=  rfl

  theorem next_previous (d : Weekday) : next (previous d) = d
    :=  match d with
    | sunday    => rfl
    | monday    => rfl
    | tuesday   => rfl
    | wednesday => rfl
    | thursday  => rfl
    | friday    => rfl
    | saturday  => rfl
  -- is equivalent to
  example (d : Weekday) : next (previous d) = d := by  cases d <;> rfl
end Weekday

/- Under the propositions-as-types correspondence,
  we can use match to prove theorems as well as define functions.
  In other words, under the propositions-as-types correspondence,
    the proof by cases is a kind of definition by cases,
    where what is being "defined" is a proof instead of a piece of data. -/
#print Bool
#print and

-- ## §7.2 Constructors with arguments
#print Prod
#print Sum
#print Sigma
-- Π is just ∀; not actually in lean4
#print Option
#print Inhabited
#print Vector

#print PProd
#print PSum
#print PSigma
#print Subtype
#print Quot
#print Quotient
#print Quotient.lift
#print Quotient.ind
#print PUnit

def prod_example (p : Bool × Nat) : Nat :=
  Prod.casesOn (motive := fun _ => Nat) p
    (fun b n => cond b (2 * n) (2 * n + 1))
#eval prod_example (true, 3)
#eval prod_example (false, 3)

def sum_example (s : Sum Nat Nat) : Nat :=
  Sum.casesOn (motive := fun _ => Nat) s
    (fun n => 2 * n) (fun n => 2 * n + 1)
#eval sum_example (Sum.inl 3)
#eval sum_example (Sum.inr 3)

-- Π is not in Lean4, but you can just use ∀
#check ∀ n : Nat, Vector Nat n

/- As with function definitions, Lean's inductive definition syntax will
    let you put named arguments to the constructors before the colon: -/
namespace _temp_hidden_
inductive Prod (α : Type u) (β : Type v) where
  | mk (fst : α) (snd : β) : Prod α β
inductive Sum (α : Type u) (β : Type v) where
  | inl (a : α) : Sum α β
  | inr (b : β) : Sum α β
end _temp_hidden_

/- keyword `structure` defines an inductive type as well as its projections, at the same time. -/
namespace _temp_hidden_
structure Prod' (α : Type u) (β : Type v) where
  mk :: -- default constructor name is `mk`
    fst : α
    snd : β
end _temp_hidden_

structure Color where
  red : Nat
  green : Nat
  blue : Nat
deriving Repr

def yellow := Color.mk 255 255 0

#eval Color.red yellow

structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)

/- Note:
  In the semantics of dependent type theory,
  there is **no built-in notion of a partial function**.  Every element of
  a function type `α → β` or a dependent function type `(a : α) → β`
  is assumed to have a value at every input.  The `Option` type provides
  a way of representing partial functions.  An element of `Option β` is
  either `none` or of the form `some b`, for some value `b : β`.
  Thus we can think of an element `f` of the type `α → Option β` as being
    a partial function from `α` to `β`: for every `a : α`, `f a` either
    returns `none`, indicating `f a` is "undefined", or `some` `b`.

  An element of `Inhabited α` is simply a witness to the fact that
    there is an element of `α`. Later, we will see that `Inhabited` is
    an example of a _type class_ in Lean:
      Lean can be instructed that suitable base types are inhabited, and
      can automatically infer that other constructed types are inhabited on that basis.-/

#synth Inhabited Nat
#synth Inhabited Bool
#synth Inhabited (Option Nat)
#synth Inhabited (Nat × Nat)
#synth Inhabited (Nat → Nat)
#synth Inhabited (Nat → Bool)
#synth Inhabited (Nat → Nat × Bool)
#synth Inhabited (Nat → Option Nat)
#synth Inhabited (Nat → Nat → Nat)
#synth Inhabited (Nat → Nat → Bool)

section
  variable {α : Type u} {β : Type v} {γ : Type w} [Inhabited α] [Inhabited β] [Inhabited γ]
  #synth Inhabited (Type u)
  #print instInhabitedSort
  #synth Inhabited (α × β)

  variable (f : α -> Option β) (g : β -> Option γ)
  partial def pf (x : Nat) : Nat :=if x > 10 then x else sorry
  #check pf
  /-- error: cannot evaluate code because 'tpil.pf' uses 'sorry' and/or contains errors -/
  #guard_msgs in #eval! pf 5
  def partial_comp (f : α -> Option β) (g : β -> Option γ) (x : α): Option γ := Option.bind (f x) g
  -- ! infix `>>=` fails with universe-polymorphism
  /--error: Application type mismatch: The argument
  g
has type
  (Nat → Type) → Option.{0} Bool
of sort `Type 1` but is expected to have type
  ?m.9 x → Option.{0} Bool
of sort `Type` in the application
  @Bind.bind.{0, 0} Option.{0} (@Monad.toBind.{0, 0} Option.{0} instMonadOption.{0}) (?m.9 x) Bool ?m.6 g
-/ #guard_msgs in
  def partial_comp_infix (f : Nat -> Option (Nat -> Type)) (g : (Nat -> Type) -> Option Bool) : (Nat -> Option Bool) :=
    fun x => f x >>= g

  /--info: Bind.bind.{u, v} {m : Type u → Type v} [self : Bind.{u, v} m] {α β : Type u} : m α → (α → m β) → m β -/
  #guard_msgs in #check Bind.bind
  /--info: Option.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} : Option.{u_1} α → (α → Option.{u_2} β) → Option.{u_2} β -/
  #guard_msgs in #check Option.bind

  #print instInhabitedNat
  #print instInhabitedBool

  instance : Nat := 0
  example : Bool := false
  -- notice how you can use `where` to define instances, even when it's introduced via `example`
  example : Inhabited (Nat → Nat) := by infer_instance
  example : Inhabited (α × β) where
    default := (default, default)
  example : Inhabited (α ⊕ β) where
    default := .inl default
  example : Inhabited (δ → β) where
    default := fun _ => default
end


-- ## §7.3 Inductively Defined Propositions
variable (α : Sort u)
#print Unit
#print PUnit
example : Unit = PUnit.{1} := rfl
#check PUnit.{0}
#print True

#print Empty
#print PEmpty
#check PEmpty.{0}
#print False
theorem empty_is_pempty_1 : Empty = PEmpty.{1} := by admit


#print Prod
#print MProd
#print PProd
#check PProd.{0,0}
#print And

#print Sum
#print PSum
#check PSum.{0,0}
#print Or

#print Sigma -- Σ
#print PSigma
#check PSigma.{0,0} (α := True)
#print Exists -- ∃
#check Exists (α := True)
#print Subtype -- { x // p x }

#print Quot
#print Quotient
#print Quotient.lift
#print Quotient.ind

-- ## §7.4 Nat
#print Nat.rec
#print Nat.recOn
#print Nat.add
#synth Add Nat
#print instAddNat


-- ## §7.5 Other Recursive Data Types
-- ## §7.6 Tactics for Inductive Types
/- The `cases` tactic works on elements of an inductively defined type:
  it decomposes the element according to each of the possible constructors,
  reducing the goal to cases in which `x` is replaced by each of the constructions.
  If the expression you case on does not appear in the goal,
    the tactic uses `have` to put the type of the expression into the context.

  `cases` allows you to choose the names for each alternative using a `with` clause.
  The alternatives for each constructor don't need to be solved in the order the constructors were declared.
  Lean also provides a complementary `case` tactic, which allows you to focus on goal assign variable names.

  `cases` detects any items in the local context that depend on the target variable;
    it reverts these elements, does the split, and reintroduces them.
  When using `cases` after `generalize` or `induction`,
    you may need to manually use `revert` or `clear`.

  * Note that `cases` can be used to produce data as well as prove propositions.

  Just as the `cases` tactic can be used to carry out proof by cases,
    the `induction` tactic can be used to carry out proofs by induction.
  The syntax is similar to that of cases, except that
    the argument **can only be a term in the local context**.
  The `induction` tactic also supports user-defined induction principles with multiple targets (aka major premises).

  The `match` notation can be used in tactic mode as well as term mode;
    tactics like `intro` and `funext` incorporates pattern destructuring as well.
-/

section -- ### injection and contradiction
/- By design, the elements of an inductive type are freely generated, i.e.,
    the constructors are injective and have disjoint ranges.
  The `injection` tactic is designed to make use of this fact: -/
open Nat
example (m n k : Nat) (h : succ (succ m) = succ (succ n))
        : n + k = m + k := by
  injection h with h'
  injection h' with h''
  rw [h'']

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by  injection h
example (m n : Nat) (h : succ m = 0) : n = n + 7 := by  contradiction
example (h : 7 = 4) : False := by  contradiction  -- or `exfalso; assumption`
end

-- ## §7.7 Inductive Families
inductive Vect (α : Type u) : Nat → Type u where
  | nil  : Vect α 0
  | cons : α → {n : Nat} → Vect α n → Vect α (n + 1)
#print Vector
#print Vector.mk

#print Eq
#print HEq
#print Not
#print Ne

/- For each fixed `α : Sort u` and `a : α`, a family of types
    `Eq a x` is constructed, indexed by `x : α`. Notably, however,
    there is only one constructor, `refl`, which is an element of `Eq a a`.
  Intuitively, the only way to construct a proof of `Eq a x` is to use reflexivity,
    in the case where `x is a`; `Eq a a` is the only inhabited type in the family.
  The elimination principle generated by Lean is as follows: -/
set_option pp.proofs true in #check (@Eq.rec)
#print Eq.rec
#print Eq.subst
#print Eq.casesOn
#print Eq.ndrec

/- In the type theory literature, there are further generalizations of inductive definitions,
    for example, the principles of induction-recursion and induction-induction.
  These are not supported by Lean. -/

-- ## §7.8 Axiomatization
/- `imax`
  Generally speaking, for an inductive type in `Prop`,
    the motive of the elimination rule is required to be in `Prop`.
  There is an exception to this:
    we are allowed to eliminate from an inductively defined `Prop` to an arbitrary `Sort`
    when there is only one constructor and each constructor argument is either in `Prop` or an index.
  The intuition is that in this case the elimination does not
    make use of any information that is not already given by the mere fact that
    the type of argument is inhabited.
  This special case is known as _singleton elimination_. -/

-- ## §7.9 Mutual and Nested
mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : (n : Nat) → Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : (n : Nat) → Even n → Odd (n + 1)
end
#print Even
#print Odd

inductive Tree (α : Type u) where
  | mk : α → List (Tree α) → Tree α
#print Tree
/- This is known as a nested inductive type.
  It falls outside the strict specification of an inductive type given in the last section
    because `Tree` does not occur **strictly positively** among the arguments to `mk`,
    but rather nested inside the List type constructor.
  Lean then automatically builds the isomorphism
    between `TreeList α` and `List (Tree α)` in its kernel,
    and defines the constructors for `Tree` in terms of the isomorphism. -/

-- end cpt7
-- end tpil - * turns out the outmost namespace and section automatically end at the end of file.
